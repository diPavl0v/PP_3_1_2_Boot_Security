<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ru">
<head th:fragment="head(title)">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- CSRF для Fetch/JQuery -->
    <meta name="_csrf" th:content="${_csrf.token}">
    <meta name="_csrf_header" th:content="${_csrf.headerName}">

    <title th:text="${title}">App</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">

    <!-- Базовые хелперы для REST + Fetch -->
    <script defer>
        // CSRF helpers
        function getCsrf() {
            const token = document.querySelector('meta[name="_csrf"]')?.content || '';
            const header = document.querySelector('meta[name="_csrf_header"]')?.content || 'X-CSRF-TOKEN';
            return { token, header };
        }

        // Обёртка над fetch: автоматически проставляет CSRF для методов, отличных от GET/HEAD/OPTIONS/TRACE
        async function apiFetch(url, options = {}) {
            const opts = { credentials: 'same-origin', headers: {}, ...options };
            opts.method = (opts.method || 'GET').toUpperCase();

            // JSON по умолчанию
            if (opts.body && !(opts.body instanceof FormData)) {
                opts.headers['Content-Type'] = opts.headers['Content-Type'] || 'application/json;charset=UTF-8';
                if (typeof opts.body !== 'string') opts.body = JSON.stringify(opts.body);
            }

            // CSRF
            if (!['GET', 'HEAD', 'OPTIONS', 'TRACE'].includes(opts.method)) {
                const { token, header } = getCsrf();
                if (token) opts.headers[header] = token;
            }

            const resp = await fetch(url, opts);
            if (!resp.ok) {
                const text = await resp.text().catch(() => '');
                throw new Error(text || resp.statusText);
            }
            // Пытаемся распарсить JSON, иначе возвращаем как текст
            const ct = resp.headers.get('content-type') || '';
            return ct.includes('application/json') ? resp.json() : resp.text();
        }

        // Утилиты
        function formToJson(form) {
            const obj = {};
            new FormData(form).forEach((v, k) => {
                // Поддержка чекбоксов множественных значений
                if (obj[k] !== undefined) {
                    if (!Array.isArray(obj[k])) obj[k] = [obj[k]];
                    obj[k].push(v);
                } else {
                    obj[k] = v;
                }
            });
            return obj;
        }
    </script>
</head>

<body th:fragment="nav">
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container-fluid">
        <a class="navbar-brand" th:href="@{/}">PP 3.1.2</a>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#nav"
                aria-controls="nav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div id="nav" class="collapse navbar-collapse">
            <ul class="navbar-nav me-auto">
                <li class="nav-item"><a class="nav-link" th:href="@{/user}">User</a></li>
                <li class="nav-item"><a class="nav-link" th:href="@{/admin}">Admin</a></li>
            </ul>

            <span class="navbar-text me-3" th:text="${#authentication?.name}">user</span>

            <form th:action="@{/logout}" method="post" class="d-inline">
                <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>
                <button class="btn btn-outline-light btn-sm" type="submit">Logout</button>
            </form>
        </div>
    </div>
</nav>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
</body>
</html>
